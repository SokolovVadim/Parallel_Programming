Минусы отсутствия нормальных семинаров - я не могу предугадать ваши вопросы. Задавайте мне возникающие вопросы в ЛС, пояснения/ответы буду писать здесь.

- Ограничения для динамической балансировки не проговорил в видео, в условиях в таблице оно правильное. Ещё их пропишу: процессов n+1, длина чисел 9*M (M кратно n).

- Мы считываем числа по 9 цифр, так как они таким образом помещаются в int. Производить вычисления на char будет очень медленно.

- Все процессы производят длинное суммирование (числа будут большими). Не надейтесь, что кусок процесса можно будет вычислить с помощью long long int.

- Отсечка по сумме первых локальных разрядов помогает сократить время вычисления почти в два раза (кроме "999999999", мы считаем один случай вместо двух). Пересылка разрядов в таком случае будет происходить не по цепочке, а по готовности, что ускорит процесс выбора.
ещё раз, про динамическую балансировку.

- slave получает от root блок
1) если младшие разряды в сумме дают 999999999, то считает ОБА варианта (спекулятивное вычисление) и отправляет ДВА результата root-у
2) если младшие разряды в сумме НЕ дают 999999999, то считает ОДИН вариант и отправляет ОДИН результат root-у

- под результатом понимается результат суммирования и перенос разряда на следующий блок

- после сбора всех результатов root проходит по полученным блокам и получает результат ("сшивает") таким образом:
1) для спекулятивных вычислений происходит выбор нужного варианта по переносу разряда предыдущего блока
2) для НЕ спекулятивных производится суммирование переноса разряда предыдущего блока с младшими разрядами этого блока.

Следующий шаг по улучшению программы - реализовать "сшивку" ответа параллельно со сбором результатов (опционально) 
 
И постарайтесь при написании программ избегать копирования строк, массивов и т.д. 

